export var GAP=8,MIN_ASPECT_RATIO_DEFAULT=3/4;export var FOCUS_CROP_REDUCTION=0.7;export default class DynamicVideoLayout{minAspectRatio=MIN_ASPECT_RATIO_DEFAULT;getTileMinRatio(a){if(!a.canBeCropped)return a.aspectRatio;if(a.aspectRatio<this.minAspectRatio)return a.aspectRatio;return a.isFocused?this.minAspectRatio+(a.aspectRatio-this.minAspectRatio)*(1-FOCUS_CROP_REDUCTION):this.minAspectRatio}oneLineLayout(A,w,h){var d=w-GAP*(A.length-1),e=d/h;{let b=0;for(const c of A)b=acc+c.aspectRatio}var f=A.map(tile=>this.getTileMinRatio(tile));{let C=0;for(const _b of f)C=acc+_b}if(e<=g)return{cropCoefficient:1,height:d/g,minRatios:f};if(g<e&&e<sumMaxRatio){var _=(sumMaxRatio-e)/(sumMaxRatio-g);return{cropCoefficient:_,height:d/e,minRatios:f}}return{cropCoefficient:0,height:h,minRatios:f}}calculateLayout(D,w,h){const{height:_d,cropCoefficient:E,minRatios:F}=this.oneLineLayout(D,w,h),y=(h-_d)/2,I=[];let H=0;for(const[i,_B] of D.entries()){var j={id:_B.id,x:H,y,cropRatio:_B.aspectRatio,width:_B.aspectRatio*_d,height:_d};_B.canBeCropped&&(j.cropRatio=_B.aspectRatio-(_B.aspectRatio-F[i])*E,j.width=j.cropRatio*_d);H+=j.width+GAP;I.push(j)}H-=GAP;if(H<w-1){var k=(w-1-H)/2;for(const _A of I)_A.x+=k}var l=(H*_d)/(w*h);return{tiles:I,viewportUse:l,height:_d,rows:1}}calculateRowCost(aA,aB,_c,_D,_e){let _f=0;let G=0;for(let i=_D;i<=_e;i++){_f+=aB[i];G+=aA[i].aspectRatio}var _h=0,_i=Math.pow(_c-G,2);return _h+_i}distributeTilesToRows(aC,aD,_C){if(aC.length===aD)return aC.map(tile=>[tile]);var aE=aC.map(tile=>this.getTileMinRatio(tile)),n=aC.length,_g=(aF,aG)=>{if(aG===1){const aK=this.calculateRowCost(aC,aE,_C,aF,n-1);return{cost:aK,distribution:[n-aF]}}if(aF>=n)return{cost:Infinity,distribution:[]};const aH=`${aF}-${aG}`;if(_F.has(aH))return _F.get(aH);let aI=Infinity;let _E=[];const aJ=n-aF-aG+1;for(let aL=1;aL<=aJ;aL++){const aM=this.calculateRowCost(aC,aE,_C,aF,aF+aL-1),aN=_g(aF+aL,aG-1),aO=aM+aN.cost;aO<aI&&(aI=aO,_E=[aL,...aN.distribution])}const _G={cost:aI,distribution:_E};_F.set(aH,_G);return _G},{distribution:_H}=_g(0,aD),_I=[];var _F=new Map;let J=0;for(const aP of _H){var K=[];for(let i=0;i<aP;i++)K.push(aC[J+i]);_I.push(K);J+=aP}return _I}calculateMultiRowLayout(aQ,w,h,aR=1){if(aR===1)return this.calculateLayout(aQ,w,h);aQ.length<aR&&(aR=aQ.length);var aS=h-GAP*(aR-1),aT=aS/aR,aU=this.distributeTilesToRows(aQ,aR,w/aT),aV=aU.map(aX=>this.calculateLayout(aX,w,aT)),aW=Math.min(...aV.map(aY=>aY.height)),_j=aW*aR+GAP*(aR-1),_k=(h-_j)/2,L=aU.map(aZ=>this.calculateLayout(aZ,w,aW)),m=[];L.forEach(({tiles},row)=>{for(const tile of tiles){tile.y=_k+row*(aW+GAP);m.push(tile)}});return{tiles:m,rows:aR,height:aW*aR+GAP*(aR-1),viewportUse:L.reduce((bA,bB)=>bA+bB.viewportUse,0)*aW/h}}findOptimalLayout(bC,w,h){if(bC.length===1)return this.calculateLayout(bC,w,h);var bD=Array.from({length:Math.min(bC.length,5)},(_,i)=>this.calculateMultiRowLayout(bC,w,h,i+1));let bE=bD[0].viewportUse;let bF=0;for(let i=1;i<bD.length;i++)bD[i].viewportUse>bE&&(bE=bD[i].viewportUse,bF=i);if(bC.length<=5)return bD[bF];let bG=6;let bH=bC.length;let bI=this.calculateMultiRowLayout(bC,w,h,6);while (bG<=bH) {var _J=~~(bG+bH)/2,_K=this.calculateMultiRowLayout(bC,w,h,_J),M=this.calculateMultiRowLayout(bC,w,h,_J+1);_K.viewportUse>bI.viewportUse&&(bI=_K);var _l=this.calculateMultiRowLayout(bC,w,h,_J-1);if(_l.viewportUse>_K.viewportUse)bH=_J-1;else if(M.viewportUse>_K.viewportUse)bG=_J+1;else break}return bI.viewportUse>bE?bI:bD[bF]}}
